{"pageProps":{"post":{"attributes":{"title":"Time And Space","description":"This is not the final frontier"},"html":"<h3 id=\"time-and-space\">Time and Space</h3>\n<p>Lets take the time to discuss time.</p>\n<p>(whiteboard)\nFirst, Let me draw up a bit of code</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"for-non-video-viewers\">For non video viewers</h3>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum_char_codes</span>(<span class=\"hljs-params\">n: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n.<span class=\"hljs-property\">length</span>; ++i) {\n        sum += n.<span class=\"hljs-title function_\">charCodeAt</span>(i);\n    }\n\n    <span class=\"hljs-keyword\">return</span> sum;\n}\n</code></pre>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"what-is-time-and-space-complexity\">What is time and space complexity?</h3>\n<p>The simpliest way to put this its as your input grows, how fast does\ncomputation or memory grow?</p>\n<h4 id=\"in-the-real-world\">In the real world</h4>\n<p>obviously memory growing is not computationally free, but in the matter of\nthinking about algorithms, we don&#39;t necessarily think about that.</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"how-we-measure-complexity\">How we measure complexity</h3>\n<p>all complexity is always related to input.  So if a function takes in 1\nargument, then we can describe the complexity in terms of <code>N</code>.</p>\n<p>Graphs, which have vertices (nodes) and edges are often described in <code>V</code> and\n<code>E</code>.  This will make more sense as time goes on.</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"lets-go-back-to-our-example\">Lets go back to our example</h3>\n<h4 id=\"for-non-video-viewers-1\">For non video viewers</h4>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum_char_codes</span>(<span class=\"hljs-params\">n: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n.<span class=\"hljs-property\">length</span>; ++i) {\n        sum += n.<span class=\"hljs-title function_\">charCodeAt</span>(i);\n    }\n\n    <span class=\"hljs-keyword\">return</span> sum;\n}\n</code></pre>\n<p>Its obvious to see that we have an <code>N</code> relationship.  But is that technically\ntrue?</p>\n<p>Lets be real, adding to a number costs some computation, lets say 1 unit of\ncomputation.  calling <code>charCodeAt</code> costs 4 units of computation.  If that is\nthe case, we really have a <code>5N</code> function (<code>(4 + 1) * len(n)</code>).</p>\n<p>How come we don&#39;t specify it with the number at the end?  5N is bigger than N,\nright?</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"what-is-big-oh\">What is Big Oh?</h3>\n<p>This is because we use Big Oh notation, <code>O(N)</code> (pronounced Oh of N).  What BigO\nis specifically, besides for sounding like a gas station name, is the UPPER\nBOUNDS to the running time.  There are two things to consider.</p>\n<ol>\n<li>the constant, often denoted with <code>k</code> or <code>c</code> is REALLY hard to determine.</li>\n<li>in the end, the constant doesn&#39;t matter as much as the growth</li>\n</ol>\n<p>So common practice is to <em>discover</em> the WORST CASE scenario and measure its\nscaling factor (relative to input).</p>\n<h3 id=\"lets-do-an-example\">Lets do an example</h3>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h4 id=\"for-non-video-viewers-2\">For non video viewers</h4>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum_char_codes</span>(<span class=\"hljs-params\">n: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n.<span class=\"hljs-property\">length</span>; ++i) {\n        <span class=\"hljs-keyword\">const</span> charCode = n.<span class=\"hljs-title function_\">charCodeAt</span>(i);\n        <span class=\"hljs-comment\">// Capital E</span>\n        <span class=\"hljs-keyword\">if</span> (charCode === <span class=\"hljs-number\">69</span>) {\n            <span class=\"hljs-keyword\">return</span> sum;\n        }\n\n        sum += charCode;\n    }\n\n    <span class=\"hljs-keyword\">return</span> sum;\n}\n</code></pre>\n<h3 id=\"this-is-why-we-do-worst-case\">This is why we do worst case</h3>\n<p>It is obvious that if we have a string starting with capital E, for those that\ndon&#39;t know their char codes, that our function would only run 1 operation and\nreturn.  It is effectively constant.</p>\n<p>If the string has an E somewhere within, it is runtime would be <code>O(cN)</code>, where\n<code>c</code> is less than 1.</p>\n<p>If the string has no E, then we would simply say this function runs in <code>O(N)</code>.\nIn typical complexity measurement, the best case has no need to cover.  In the\nreal world though, you can make incredible improvements to time / space by\nthese types of optimizations.</p>\n<p>In other words, academic classification does not mean one is slower than\nanother.</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"the-common-complexities\">The common complexities</h3>\n<p><a href=\"https://www.hackerearth.com/practice/notes/big-o-cheatsheet-series-data-structures-and-algorithms-with-thier-complexities-1/\">Source</a>\n<img src=\"/dsa/./images/big-o-face.png\" alt=\"Big O Notation\"></p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h3 id=\"one-thing-people-forget-about-big-o\">One thing people forget about big o</h3>\n<p>Big literally means the <em>UPPER BOUND</em> running time.  Almost exclusively it also\nrefers to the <em>WORST CASE</em>.</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n\n<h3 id=\"why-so-obviated\">Why so obviated?</h3>\n<p>There are other resources out there to dive deep into big o notation.  And I\njust don&#39;t think we need Yet Another Big O explanation.  Instead I am going to\nfocus on actively looking at running times and we will determine things\ntogether.</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n","slug":"time-and-space-complexity","title":"Time And Space","section":"Algorithms and Time Space Complexity","icon":"dumpster-fire","filePath":"/home/runner/work/fem-algos/fem-algos/lessons/02-algorithms-and-time-space-complexity/A-time-and-space-complexity.md","nextSlug":"/dsa/lessons/our-first-datastructure/ready","prevSlug":"/dsa/lessons/introduction/terms"}},"__N_SSG":true}